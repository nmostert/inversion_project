# %%
"""
# Colima Inversion Examples
"""

# %%
import copy
from tabulate import tabulate
from pandas import ExcelWriter
from functools import reduce
from time import process_time
from scipy.optimize import minimize
from scipy.sparse.linalg import lsqr
from scipy.stats import beta, expon, truncnorm, norm, uniform
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import sys
sys.path.append("..")
import project.vis_utils as vis
import project.io_utils as io
import project.inversion as inv
import matplotlib.colors as colors

pd.options.display.float_format = '{:,g}'.format
plt.style.use(['ggplot'])

import logging

logging.basicConfig(level=logging.INFO)


# %%
""" ### Observation Data

Reading in Colima observation dataset and extracting grid
"""

# %%
filename = "../data/colima/colima_real_data.csv"

raw_df, grid = io.import_colima(filename)


# grid.to_csv("../data/colima/colima_grid.csv",
#             sep=" ", header=False, index=False)
grid = io.read_grid("../data/colima/colima_grid.csv")

io.print_table(raw_df.head())

io.print_table(grid)
# %%
""" ## Pre Processing

Residual column is added for consistency later on.
"""

# %%
vis.plot_sample(raw_df, vent=(0, 0), log=False,
                title="Colima 1913 data", cbar_label="Mass/Area")
plt.show()
# plt.savefig("colima/all_points.png", dpi=200, format='png')

obs_df = raw_df.copy()

# obs_df = obs_df.drop([16, 18, 17, 37, 31])
# This is going to be 100 across. Just needs to be the same as the other dfs.
obs_df["Residual"] = obs_df["MassArea"]/obs_df["MassArea"]*100

vis.plot_sample(obs_df, vent=(0, 0), log=False, title="Preprocessed Data",
                cbar_label="Mass/Area")
# plt.savefig("colima/All_trans.png", dpi=200, format='png')
plt.show()

# %%
""" ##Reading in Tephra2 datasets

To demonstrate consistency with Tephra2, this dataset must be generated by
Tephra2 using the exact same parameters as is used in the forward modelling.
"""

# %%
t2_df, _, _, _ = io.read_tephra2("../data/colima/colima_noaa_wind_out.txt", )

t2_df["Residual"] = t2_df["MassArea"].values/obs_df["MassArea"].values

io.print_table(t2_df.head())

# %%
t2_const_df, _, _, _ = io.read_tephra2(
    "../data/colima/connor_marks_wind_out.txt")

t2_const_df["Residual"] = t2_const_df["MassArea"]/obs_df["MassArea"]

io.print_table(t2_const_df.head())


# %%
""" ## Set up inversion configuration

- Read in Tephra2 config file
- Set global parameters
- Set other inversion parameters

# Internal consistency requirements

In order to demonstrate perfect internal consistency we need our forward model
to invert perfectly, i.e. return the exact input parameters that simulated it.
Such a perfect inversion requires that the release points in the column be in
exactly the same place in the forward model as in the inversion.

The forward model evenly spaces the release points between the vent height and
the plume height, putting a point at each. In order to demonstrate internal
consistency, those same points need to be used for inversion. To this end, a
theoretical maximum column height and number of inversion column steps is
calculated that places release points for inversion at those same points in the
column that would be used in the forward model, while adding evenly spaced
points above the actual plume height.
If internal consistency is not required these values can be set for efficient
inversion.
"""

# %%
config = io.read_tephra2_config("../data/colima/colima_config.txt")

globs = {
    "LITHIC_DIAMETER_THRESHOLD": 7.,
    "PUMICE_DIAMETER_THRESHOLD": -1.,
    "AIR_VISCOSITY": 0.000018325,
    "AIR_DENSITY":  1.293,
    "GRAVITY": 9.81,
}

# Update parameters
# COL STEPS need to be small enough so the
# layer height can be kept for an inversion with a high H
config["COL_STEPS"] = 20
theoretical_max = 45000  # The H value will be as close as possible to this
layer_thickness = (
    (config["PLUME_HEIGHT"]-config["VENT_ELEVATION"])/config["COL_STEPS"])

inversion_steps = np.round((config["COL_STEPS"]*(theoretical_max -
                            config["VENT_ELEVATION"])) /
                           (config["PLUME_HEIGHT"]-config["VENT_ELEVATION"]))
closest_H = ((inversion_steps*(config["PLUME_HEIGHT"] -
             config["VENT_ELEVATION"])) /
             config["COL_STEPS"]) + config["VENT_ELEVATION"]
print("This number needs to be low enough to invert efficiently:")
print(inversion_steps)
print("If not, decrease COL_STEPS or theoretical max")
print("Closest Possible Theoretical Max Column Height:")
print(closest_H)

config["PART_STEPS"] = 9

config["MAX_GRAINSIZE"] = -5
config["MIN_GRAINSIZE"] = 4

add_params = {
    # Constant wind speed (m/s)
    "WIND_SPEED": 10.345736331007556,
    # Constant wind angle (radians anti-clockwise from Easting)
    "WIND_ANGLE": np.radians(40.7454850322874),
    "INV_STEPS": int(inversion_steps),
    "THEO_MAX_COL": closest_H
}
# To ensure monotonicity:
# config["DIFFUSION_COEFFICIENT"] = 1.7*config["FALL_TIME_THRESHOLD"]

print("INPUT PARAMETERS:")
io.print_table(config, tablefmt="latex")
io.print_table(globs, tablefmt="latex")
io.print_table(add_params, tablefmt="latex")

# %%
""" ## Phi class calculations

# Theoretical phi parameters

The function `get_phi_steps` generates phi classes using Tephra2 input
variables in the exact same way as Tephra2.
"""

# %%
theo_phi_steps = inv.get_phi_steps(config["MIN_GRAINSIZE"],
                                   config["MAX_GRAINSIZE"],
                                   config["PART_STEPS"],
                                   config["MEDIAN_GRAINSIZE"],
                                   config["STD_GRAINSIZE"],
                                   globs["LITHIC_DIAMETER_THRESHOLD"],
                                   globs["PUMICE_DIAMETER_THRESHOLD"],
                                   config["LITHIC_DENSITY"],
                                   config["PUMICE_DENSITY"])
step_width = (config["MAX_GRAINSIZE"] -
              config["MIN_GRAINSIZE"])/config["PART_STEPS"]

io.print_table(pd.DataFrame(theo_phi_steps))


probs = [phi["probability"].copy() for phi in theo_phi_steps]
x = [phi["centroid"] for phi in theo_phi_steps]
labels = [phi["interval"] for phi in theo_phi_steps]
fig, ax = plt.subplots(facecolor='w', edgecolor='k')
ax.bar(x, probs, width=1, align="center")
ax.set_xticks(x)
ax.set_xticklabels(labels)
plt.xlabel("Phi Interval")
plt.show()


# %%
""" ### Naive TGSD calculation

The function `get_tgsd` calculates performs a naive calculation of the TGSD.
None
It sums up the total mass in each phi class, and then normalises that to add
up to 1.

We often use this naive TGSD estimation as a prior.
"""

# %%
naive_tgsd = inv.get_tgsd(obs_df, theo_phi_steps)
fig, ax = plt.subplots(facecolor='w', edgecolor='k')
ax.bar(x, naive_tgsd, width=1, align="center")
ax.set_xticks(x)
ax.set_xticklabels(labels, rotation=90)
plt.xlabel("Phi Interval")
plt.show()

naive_phi_steps = []
for i, phi in enumerate(theo_phi_steps):
    phi_cpy = copy.deepcopy(phi)
    phi_cpy["probability"] = naive_tgsd[i]
    naive_phi_steps.append(phi_cpy)
io.print_table(pd.DataFrame(naive_phi_steps))

# %%
""" ## Forward modelling

Our forward model is as close to Tephra2 as possible, except that it does not
support separate wind levels.
"""

# %%
grid = obs_df[["Easting", "Northing"]]
wind_angle = np.radians(40.7454850322874)

u = add_params["WIND_SPEED"]*np.cos(add_params["WIND_ANGLE"])
v = add_params["WIND_SPEED"]*np.sin(add_params["WIND_ANGLE"])

forward_df = inv.gaussian_stack_forward(
    grid, int(config["COL_STEPS"]), config["VENT_ELEVATION"],
    config["PLUME_HEIGHT"], 2500, theo_phi_steps, (
        config["ALPHA"], config["BETA"]),
    config["ERUPTION_MASS"],
    (u, v), config["DIFFUSION_COEFFICIENT"], config["EDDY_CONST"],
    config["FALL_TIME_THRESHOLD"]
)

forward_df["radius"] = np.sqrt(
    forward_df["Easting"]**2 + forward_df["Northing"]**2)
forward_df = forward_df.sort_values(by=['radius'])
forward_df["Residual"] = forward_df["MassArea"] / \
    obs_df["MassArea"]
io.print_table(forward_df.head())
print("Wind parameters:")
print("u = %g, v = %g" % (u, v))

# %%
""" ## Visual Analysis

Here we use our plotting library to visualise the observation and synthetic
datasets.
"""

# %%


fig, axs = plt.subplots(1, 4, figsize=(
    18, 6),
    gridspec_kw={'width_ratios': [.8, .8, .8, 1]})
axs = axs.ravel()

vis.plot_sample(obs_df, vent=(0, 0), log=True, bounds=(50, 1500),
                title="Colima Observations", show_cbar=False,
                cbar_label="Mass/Area", ax=axs[0])

vis.plot_sample(forward_df, vent=(0, 0), log=True, bounds=(50, 1500),
                show_cbar=False,
                title="Forward Simulation (Const. Wind)",
                cbar_label="Mass/Area", ax=axs[1])
vis.plot_sample(t2_const_df, vent=(0, 0), log=True, bounds=(50, 1500),
                show_cbar=False,
                title="Tephra2 Simulation (Const. Wind)",
                cbar_label="Mass/Area", ax=axs[2])
vis.plot_sample(t2_df, vent=(0, 0), log=True, bounds=(50, 1500),
                title="Tephra2 Simulation (NOAA Wind)",
                cbar_label="Mass/Area", ax=axs[3])
plt.tight_layout()
axs[0].set_xlim([-3000, 6500])
axs[0].set_ylim([-500, 12000])
axs[1].set_xlim([-3000, 6500])
axs[1].set_ylim([-500, 12000])
axs[2].set_xlim([-3000, 6500])
axs[2].set_xlim([-3000, 6500])
plt.show()


# %%
""" ### Residual plots

These plots compare the synthetic datasets with the observation dataset in each
case.

The residual calculation is: `(synthetic/observation)*100`
"""

# %%
fig, axs = plt.subplots(1, 3, figsize=(
    18, 6), facecolor='w', edgecolor='k')
axs = axs.ravel()


vis.plot_residuals(forward_df, vent=(0, 0), values="Residual",
                   title="Forward Simulation (Const. Wind)",
                   plot_type="size", ax=axs[0])
vis.plot_residuals(t2_const_df, vent=(0, 0), values="Residual",
                   title="Tephra2 Simulation (Const. Wind)",
                   plot_type="size", ax=axs[1])
vis.plot_residuals(t2_df, vent=(0, 0), values="Residual",
                   title="Tephra2 Simulation (NOAA Wind)",
                   plot_type="size", ax=axs[2])


plt.tight_layout()
plt.show()

fig, axs = plt.subplots(1, 3, figsize=(
    18, 6), facecolor='w', edgecolor='k')
axs = axs.ravel()


vis.plot_residuals(forward_df, vent=(0, 0), values="Residual",
                   title="Forward Simulation (Const. Wind)",
                   plot_type="cmap", ax=axs[0], show_cbar=False)
vis.plot_residuals(t2_const_df, vent=(0, 0), values="Residual",
                   title="Tephra2 Simulation (Const. Wind)",
                   plot_type="cmap", ax=axs[1], show_cbar=False)
vis.plot_residuals(t2_df, vent=(0, 0), values="Residual",
                   title="Tephra2 Simulation (NOAA Wind)",
                   plot_type="cmap", ax=axs[2], show_cbar=True)


# plt.tight_layout()
plt.show()

# %%
""" ### Distance plots

These plots sort the points by their distance from the vent, giving a general
sense of the decay curves in all directions from the vent.
"""

# %%
fig, axs = plt.subplots(2, 1, figsize=(
    8, 10), facecolor='w', edgecolor='k')
axs = axs.ravel()

axs[0].plot(obs_df["radius"].values, obs_df["MassArea"].values,
            'C0o-', label="Observations")
# plt.plot(rotdf["radius"].values, rotdf["MassArea"].values, 'C1o-')
axs[0].plot(forward_df["radius"].values, forward_df["MassArea"].values,
            'C1o', label="Forward (Const. Wind)")
axs[0].plot(t2_const_df["radius"].values,
            t2_const_df["MassArea"].values, 'C2o',
            label="Tephra2 (Const. Wind)")
axs[0].plot(t2_df["radius"].values, t2_df["MassArea"].values,
            'C3o', label="Tephra2 (NOAA Wind)")
axs[0].legend()
axs[0].set_xlabel("Distance from vent (m)")
axs[0].set_ylabel("Mass/Area")

axs[1].plot(forward_df["radius"].values, forward_df["Residual"].values *
            100, 'C1o', label="Forward (Const. Wind)")
axs[1].plot(t2_const_df["radius"].values, t2_const_df["Residual"].values *
            100, 'C2o', label="Tephra2 (Const. Wind)")
axs[1].plot(t2_df["radius"].values, t2_df["Residual"].values *
            100, 'C3o', label="Tephra2 (NOAA Wind)")
axs[1].axhline(100, linestyle="--", lw=1, c="gray")
axs[1].legend()
axs[1].set_xlabel("Distance from vent (m)")
axs[1].set_ylabel("Sim as % of Real")
plt.show()

# %%
""" ## Prior Distributions

Here we can define prior distributions to be used in the inversion. These will
passed to the sampler using the `param_config` dict below.


"""

# %%


def col_truncnorm(mean, top=add_params["THEO_MAX_COL"]):
    bottom = 5000
    std = (top - bottom)/4
    standard_a, standard_b = (bottom - mean) / std, (top - mean) / std
    return truncnorm.rvs(standard_a, standard_b, loc=mean, scale=std)


def lognorm(prior, bottom=0):
    std_norm = norm.rvs()
    std_lognorm = np.exp(std_norm)
    lognorm = bottom + (prior-bottom)*std_lognorm
    return lognorm


def normal(prior):
    std_norm = norm.rvs()
    normal = prior*std_norm
    return normal


def uninformed(bottom, top):
    unif = uniform.rvs(loc=bottom, scale=(top-bottom))
    return unif

def fixed(value):
    return value


# %%
""" ## Parameter Configuration

Here configure the inversion parameters.

- `"value"` is a list of distribution parameters used in the sample function.
    These will be splat into the sample function during sampling, so they need
    to be in the correct order.
- `"invert"` is a boolean value indicating if the parameter should be inverted
    or not. If True, the parameter will be optimized during the
    downhill-simplex phase. Otherwise the parameter will be kept fixed.
- `"sample_function"` is the prior distribution to sample from during the
    initial sampling phase. These are chosen from the above list.
"""

# %%
# param_config = {
#     "a": {
#         "value": [1.01, 5],
#         "invert": True,
#         "sample_function": uninformed
#     },
#     "b": {
#         "value": [1.01, 5],
#         "invert": True,
#         "sample_function": uninformed
#     },
#     "h1": {
#         "value": [5000, add_params["THEO_MAX_COL"]],
#         "invert": True,
#         "sample_function": uninformed
#     },
#     "u": {
#         "value": [0, 10],
#         "invert": True,
#         "sample_function": uninformed
#     },
#     "v": {
#         "value": [0, 10],
#         "invert": True,
#         "sample_function": uninformed
#     },
#     "D": {
#         "value": [0.5*config["FALL_TIME_THRESHOLD"],
#                   1.4*config["FALL_TIME_THRESHOLD"]],
#         "invert": True,
#         "sample_function": uninformed
#     },
#     "ftt": {
#         "value": [con fig["FALL_TIME_THRESHOLD"], 10000],
#         "invert": False,
#         "sample_function": uninformed
#     },
# }

param_config = {
    "a": {
        "value": [config["ALPHA"]],
        "invert": True,
        "sample_function": fixed
    },
    "b": {
        "value": [config["BETA"]],
        "invert": True,
        "sample_function": fixed
    },
    "h1": {
        "value": [config["PLUME_HEIGHT"]],
        "invert": True,
        "sample_function": fixed
    },
    "u": {
        "value": [u],
        "invert": True,
        "sample_function": fixed
    },
    "v": {
        "value": [v],
        "invert": True,
        "sample_function": fixed
    },
    "D": {
        "value": [config["DIFFUSION_COEFFICIENT"]],
        "invert": True,
        "sample_function": fixed
    },
    "ftt": {
        "value": [config["FALL_TIME_THRESHOLD"]],
        "invert": False,
        "sample_function": fixed
    },
}


# I TESTED SOME FIXED PARAMETER RUNS HERE.

# full_inversion_priors = {
#     "a": 1.00002,
#     "b": 1.13405,
#     "h1": 44908,
#     "u": 2.60482,
#     "v": 5.33615,
#     "D": 5999.9,
#     "ftt": 6458,
# }

# phi_probs = [
#     0.058657896918929336,
#     0.15114329504320803,
#     0.15644352749157492,
#     0.15138125134809738,
#     0.17100876050061856,
#     0.1814490666782764,
#     0.06799943098150356,
#     0.01682410991463832,
#     0.045092661123153584
# ]
# param_config = {
#     "a": {
#         "value":[full_inversion_priors["a"], 5],
#         "invert":False,
#         "sample_function": uninformed
#     },
#     "b": {
#         "value":[full_inversion_priors["b"], 5],
#         "invert":False,
#         "sample_function": uninformed
#     },
#     "h1": {
#         "value":[full_inversion_priors["h1"], config["THEO_MAX_COL"]],
#         "invert":False,
#         "sample_function": uninformed
#     },
#     "u": {
#         "value":[full_inversion_priors["u"], 10],
#         "invert":False,
#         "sample_function": uninformed
#     },
#     "v": {
#         "value":[full_inversion_priors["v"], 10],
#         "invert":False,
#         "sample_function": uninformed
#     },
#     "D": {
#         "value":[full_inversion_priors["D"], 6000],
#         "invert":False,
#         "sample_function": uninformed
#     },
#     "ftt": {
#         "value":[config["FALL_TIME_THRESHOLD"], 10000],
#         "invert":False,
#         "sample_function": uninformed
#     },
# }
param_config_df = pd.DataFrame(param_config)
io.print_table(param_config_df.T)

fig, axs = plt.subplots(3, 3, figsize=(15, 15), facecolor='w', edgecolor='k')
axs = axs.ravel()

for i, (key, val) in enumerate(param_config.items()):
    x = [val["sample_function"](*val["value"]) for i in range(1000)]
    axs[i].hist(x)
    axs[i].set_title(key)
plt.show()


# %%
""" ## Inversion Test

This inversion test uses exact priors so that no actual inversion needs to be
done in the inversion of the forward model. With this biased inversion we can
test internal consistency. The input parameters need to be recovered exactly
for this test to pass.

In this test, we will be able to compare some or all of the following datasets,
the most important of which is the Forward model inversion using fixed priors.

# No inversion.
A forward modeled dataset is added, and inversion is NOT performed on it. This
gives us a baseline, and allows us to confirm the following:
    - The residual analysis plots are accurate. A dataset compared directly
    with itself should show zero residual.

# Forward model inversion using fixed priors.
This inversion should not change the parameters, as they are already optimised.
If this inversion changes the parameters then we don't have a stable model.

# Tephra2 inversion with constant wind.
Since our assumption is that Tephra2 is functionally identical to our forward
model in the case of a fixed wind profile, the results of this inversion should
be identical to the Forward model inversion. If this is not the case, we no
longer have consistency with the Tephra2 code, which is a problem.

# Observation dataset inversion.
Since we are using a single inversion run with fixed priors here, we do not
expect this inversion to be successful at all. It's still good to see what
happens.
"""

# %%
prior_phi_steps = []
for i, phi in enumerate(theo_phi_steps):
    phi_cpy = copy.deepcopy(phi)
    prior_phi_steps.append(phi_cpy)

z = np.linspace(config["VENT_ELEVATION"] + layer_thickness,
                add_params["THEO_MAX_COL"], add_params["INV_STEPS"])
q_dist = beta(config["ALPHA"], config["BETA"])

q_mass = inv.beta_plume(config["ALPHA"], config["BETA"],
                        config["PLUME_HEIGHT"],
                        config["ERUPTION_MASS"],
                        z,
                        config["VENT_ELEVATION"],
                        add_params["THEO_MAX_COL"])
forward_param_vals = {
    "a": config["ALPHA"],
    "b": config["BETA"],
    "h1": config["PLUME_HEIGHT"],
    "u": u,
    "v": v,
    "D": config["DIFFUSION_COEFFICIENT"],
    "ftt": config["FALL_TIME_THRESHOLD"]
}

priors_vals = {
    "a": param_config["a"]["sample_function"](*param_config["a"]["value"]),
    "b": param_config["b"]["sample_function"](*param_config["b"]["value"]),
    "h1": param_config["h1"]["sample_function"](*param_config["h1"]["value"]),
    "u": param_config["u"]["sample_function"](*param_config["u"]["value"]),
    "v": param_config["v"]["sample_function"](*param_config["v"]["value"]),
    "D": param_config["D"]["sample_function"](*param_config["D"]["value"]),
    "ftt": config["FALL_TIME_THRESHOLD"]
}

invert_params = {
    "a": param_config["a"]["invert"],
    "b": param_config["b"]["invert"],
    "h1": param_config["h1"]["invert"],
    "u": param_config["u"]["invert"],
    "v": param_config["v"]["invert"],
    "D": param_config["D"]["invert"],
    "ftt": False
}

print(priors_vals)
print(invert_params)
t_tot = process_time()
single_run_time = 0
wind_angle = np.radians(40.7454850322874)

names = ["No Inversion", "Forward Sim"]
# , "T2 Const. Wind", "T2 NOAA wind", "Observation Data"]
data_sets = [forward_df, forward_df]  # , t2_const_df, t2_df, obs_df]

inverted_masses_list = []
inverted_masses_list += [q_mass]
params_list = []
sim_params = forward_param_vals
params_list += [sim_params]
mass_list = []
tgsd_list = []
misfit_list = []
mass_list += [config["ERUPTION_MASS"]]
tgsd_list += [[phi["probability"].copy() for phi in prior_phi_steps]]
misfit_list += ["--"]

for name, df in zip(names[1:], data_sets[1:]):
    t = process_time()
    run_phis = copy.deepcopy(prior_phi_steps)
    print("========%s========" % name)
    out = inv.gaussian_stack_inversion(
        df,
        len(df),
        add_params["INV_STEPS"],
        config["VENT_ELEVATION"],
        add_params["THEO_MAX_COL"],
        2500,
        run_phis,
        config["ERUPTION_MASS"],
        invert_params=invert_params,
        priors=priors_vals,
        sol_iter=20,
        max_iter=40,
        tol=7,
        termination="std",
        adjust_TGSD=True,
        adjust_mass=False,
        adjustment_factor=None,
        abort_method="too_slow",
        column_cap=add_params["THEO_MAX_COL"],
        gof="chi-sqr"
    )
    inversion_table, params, misfit, status, message, param_trace, \
        misfit_trace, tgsd_trace, mass_trace = out
    inv_mass = inversion_table["Suspended Mass"].values
    inverted_masses_list += [inv_mass]
    params_list += [params]
    tgsd_list += [tgsd_trace[-2]]
    mass_list += [mass_trace[-1]]
    misfit_list += [misfit]
    io.print_table(inversion_table)
    param_trace = np.array(param_trace)
    fig, axs = plt.subplots(3, 3, figsize=(
        11, 9), facecolor='w', edgecolor='k')
    axs = axs.ravel()
    axs[0].plot(param_trace[:, 0], linewidth=.8)
    axs[0].set_title("a")

    axs[1].plot(param_trace[:, 1], linewidth=.8)
    axs[1].set_title("b")

    axs[2].plot(param_trace[:, 2], linewidth=.8)
    axs[2].set_title("h1")

    axs[3].plot(param_trace[:, 3], linewidth=.8)
    axs[3].set_title("u")

    axs[4].plot(param_trace[:, 4], linewidth=.8)
    axs[4].set_title("v")

    axs[5].plot(param_trace[:, 5], linewidth=.8)
    axs[5].set_title("Diffusion Coefficient")

    axs[8].plot(misfit_trace, linewidth=.8)
    axs[8].set_title("GoF")

#     print(sse_trace)

    plt.tight_layout()
    # # plt.savefig("colima/real_trace.png", dpi=200, format='png')
    plt.show()
    # fig, ax = plt.subplots(facecolor='w', edgecolor='k')
    # ax.bar(x, tgsd_trace[0], width=1, align="center")
    # ax.set_xticks(x)
    # ax.set_xticklabels(labels)
    # plt.xlabel("Phi Interval")
    # plt.title("Before")
    # plt.show()

    # fig, ax = plt.subplots(facecolor='w', edgecolor='k')
    # ax.bar(x, tgsd_trace[-1], width=1, align="center")
    # ax.set_xticks(x)
    # ax.set_xticklabels(labels)
    # plt.xlabel("Phi Interval")
    # plt.title("After")
    # plt.show()

    run_time = process_time() - t
    print("%s Run Time: %.5f minutes\n\n" % (name, run_time/60))


total_run_time = process_time() - t_tot

print("Total Run Time: %.5f minutes" % (total_run_time/60))

# %%
""" ## TGSD Adjustment Results

If TGSD adjustment is toggled off in the tests above, this should show no
change. Otherwise this will show the TGSD adjustment for each dataset.

Forward Sim and No Inversion should have no TGSD adjustment, even when toggled
on.
"""

# %%
plt.figure()
plt.plot([phi["probability"]
         for phi in prior_phi_steps], "o", label="Prior TGSD (Naive)")
for i, name in enumerate(names):
    plt.plot(tgsd_list[i], ".-", label=name)
plt.legend()
plt.show()


# %%
""" ## Inversion Results

Here we show the results of the parameter inversions.
"""

# %%
fig, ax1 = plt.subplots(1, 1, figsize=(
    8, 6), facecolor='w', edgecolor='k')

ltype = ["-", "--", ":", ".-", "."]

for name, mass, lt in zip(names, inverted_masses_list, ltype):
    ax1.plot(mass,
             inversion_table["Height"], lt, label=name)
ax1.legend()
# ax1.set_title("Mass in Column as inverted from various datasets")
ax1.set_ylabel("Height")
ax1.set_xlabel("Mass/Area")
ax1.set_title("Inverted Suspended Mass in Plume")
plt.tight_layout()
plt.show()
params_df = pd.DataFrame(params_list)
params_df["Dataset"] = names
params_df = params_df[["Dataset", "a", "b",
                       "h1", "u", "v", "D", "ftt"]]
params_df["M"] = mass_list
params_df["Misfit"] = misfit_list
io.print_table(params_df)

# %%
""" ## Single Inversion Diagnostics

Here we can look at the diagnostics of a single inversion at a time, as opposed
to a sampled prior inversion scheme as it would usually be applied.


"""

# %%
for i, name in enumerate(names):
    print("========%s========" % name)

    data = data_sets[i]

    io.print_table(params_list[i])

    print("GoF: ", misfit_list[i])
    q_dist = beta(params["a"], params["b"])

    phi_new = copy.deepcopy(prior_phi_steps)
    for j, new_phi in enumerate(phi_new):
        new_phi["probability"] = tgsd_list[i][j]

    q_dist = beta(params["a"], params["b"])

    grid = data[["Easting", "Northing"]]

    post_df = inv.gaussian_stack_forward(
        grid, int(config["COL_STEPS"]), config["VENT_ELEVATION"],
        params_list[i]["h1"], 2500, phi_new, (
            params_list[i]["a"], params_list[i]["b"]),
        mass_list[i],
        (params_list[i]["u"], params_list[i]["v"]
         ), params_list[i]["D"], config["EDDY_CONST"],
        config["FALL_TIME_THRESHOLD"]
    )
    if name == "No Inversion":
        data = post_df
    post_df["radius"] = np.sqrt(post_df["Easting"]**2 + post_df["Northing"]**2)
    post_df = post_df.sort_values(by=['radius'])
    post_df["Residual"] = post_df["MassArea"].values/data["MassArea"].values


#     display(post_df)
    # SPATIAL PLOTS
    fig, axs = plt.subplots(3, 1, figsize=(
        6, 18), facecolor='w', edgecolor='k')
    axs = axs.ravel()
    bounds = (50, 800)
    vis.plot_sample(data, vent=(0, 0), log=False, bounds=bounds,
                    title=name, cbar_label="Mass/Area", ax=axs[0],
                    wind=(params_list[i]["u"], params_list[i]["v"]))
    axs[0].set_xlim([-3000, 6500])
    axs[0].set_ylim([-500, 12000])
    vis.plot_sample(post_df, vent=(0, 0), log=False, bounds=bounds,
                    title="Sim using Inverted Params", cbar_label="Mass/Area",
                    ax=axs[1],
                    wind=(params_list[i]["u"], params_list[i]["v"]))
    axs[1].set_xlim([-3000, 6500])
    axs[1].set_ylim([-500, 12000])
    vis.plot_residuals(post_df, vent=(0, 0), values="Residual",
                       plot_type="size",
                       title="Residual wrt. %s" % name, ax=axs[2],
                       wind=(params_list[i]["u"], params_list[i]["v"]))
    axs[2].set_xlim([-3000, 6500])
    axs[2].set_ylim([-500, 12000])

    plt.tight_layout()
    plt.show()

    # EQUILINE PLOT

    min_mass = min((min(data["MassArea"].values),
                   min(post_df["MassArea"].values)))
    max_mass = max((max(data["MassArea"].values),
                   max(post_df["MassArea"].values)))

    fig, ax = plt.subplots(facecolor='w', edgecolor='k')
    ax.scatter(np.sqrt(data["MassArea"].values),
               np.sqrt(post_df["MassArea"].values))
    ax.plot([0, 100], [0, 100], "k:")
    ax.set_xlabel("SQRT(Observed)")
    ax.set_ylabel("SQRT(Calculated)")
    ax.set_aspect('equal', 'box')
    ax.set_xlim([np.sqrt(min_mass)-1, np.sqrt(max_mass)+1])
    ax.set_ylim([np.sqrt(min_mass)-1, np.sqrt(max_mass)+1])
    fig.tight_layout()
    plt.show()

    # DISTANCE PLOTS
    fig, axs = plt.subplots(2, 1, figsize=(
        8, 9), facecolor='w', edgecolor='k')
    axs = axs.ravel()

    axs[0].plot(data["radius"].values, data["MassArea"].values,
                'C2o-', label="Observation Data")
    axs[0].plot(post_df["radius"].values, post_df["MassArea"].values,
                'C1o', label="Posterior Simulation")
    axs[0].legend()
    axs[0].set_xlabel("Distance from vent (m)")
    axs[0].set_ylabel("Mass/Area")
    axs[0].set_xlim(1000, 13000)

    axs[1].plot(post_df["radius"].values,
                post_df["Residual"].values*100, 'C1o', label="Post/Obs")
    axs[1].axhline(100, linestyle="--", lw=1, c="gray")
    axs[1].legend()
    axs[1].set_xlabel("Distance from vent (m)")
    axs[1].set_ylabel("Sim as % of Real")
    axs[1].set_xlim(1000, 13000)
    plt.show()

    # TGSD PLOTS

    old_tgsd = [phi["probability"].copy() for phi in prior_phi_steps]
    x = [phi["centroid"] for phi in prior_phi_steps]
    labels = [phi["interval"] for phi in prior_phi_steps]

    obs_tgsd = inv.get_tgsd(data, prior_phi_steps)
    post_tgsd = inv.get_tgsd(post_df, prior_phi_steps)

    fig, ax = plt.subplots(facecolor='w', edgecolor='k')
    ax.bar([xx-0.25 for xx in x], old_tgsd, width=0.5,
           align="center", label="Prior TGSD")
    ax.bar([xx+0.25 for xx in x], tgsd_list[i],
           width=0.5, align="center", label="Post. TGSD")
    ax.set_xticks(x)
    ax.set_xticklabels(labels, rotation=90)
    ax.set_xlabel("Phi Interval")
    plt.title("TGSD before and after inversion")
    plt.legend()

    plt.show()

    fig, ax = plt.subplots(facecolor='w', edgecolor='k')
    ax.bar([xx-0.25 for xx in x], obs_tgsd, width=0.5,
           align="center", label="Obs. TGSD (Naive)")
    ax.bar([xx+0.25 for xx in x], post_tgsd, width=0.5,
           align="center", label="Post. TGSD (Naive)")
    ax.set_xticks(x)
    ax.set_xticklabels(labels, rotation=90)
    ax.set_xlabel("Phi Interval")
    plt.title("Naive estimation of TGSD")
    plt.legend()

    plt.show()

    # ERROR CONTRIBUTION PLOTS

    new_steps = copy.deepcopy(prior_phi_steps)
    for j, phi in enumerate(new_steps):
        phi["probability"] = tgsd_list[i][j]

    misfit, contributions, setup = inv.get_error_contributions(
        data, len(data), int(add_params["INV_STEPS"]),
        config["VENT_ELEVATION"], add_params["THEO_MAX_COL"], 2500, new_steps,
        params_list[i], mass_list[i], column_cap=add_params["THEO_MAX_COL"])

    point_contributions = np.sum(contributions, 0)
    phi_contributions = np.sum(contributions, 1)

    # Phi Error Contributions
    fig, ax = plt.subplots(facecolor='w', edgecolor='k')
    ax.bar(x, phi_contributions, width=0.5, align="center")
    ax.set_xticks(x)
    ax.set_xticklabels(labels)
    plt.xlabel("Phi Interval")
    plt.ylabel("Error Contribution")
    plt.title("Run %d" % i)
    plt.show()

    # Distance Error Contributions
    fig, ax = plt.subplots(facecolor='w', edgecolor='k')
    ax.plot(data["radius"], point_contributions, "C0o-")
    plt.xlabel("Distance from Vent")
    plt.ylabel("Error Contribution")
    plt.title("Run %d" % i)
    ax.set_xlim(1000, 13000)
    plt.show()

    # Spatial Error Contributions
    data["Contributions"] = point_contributions
    fig, ax = plt.subplots(1, 1, figsize=(5, 5), facecolor='w', edgecolor='k')

    vis.plot_sample(data, vent=(0, 0), log=False, values="Contributions",
                    title="Error Contributions", cbar_label="Mass/Area",
                    ax=ax, cmap="hot")
    ax.set_xlim([-3000, 6500])
    ax.set_ylim([-500, 12000])
    plt.tight_layout()
    plt.show()
#      bounds=(min(min(contributions)),max(max(contributions))),
    # Phi and Spatial Error Contributions
    fig, axs = plt.subplots(3, 3, figsize=(
        15, 15), facecolor='w', edgecolor='k')
    axs = axs.ravel()
    for j, phi_cont in enumerate(phi_contributions):
        data["Contributions"] = contributions[j]
#         display(data[["Contributions", "MassArea"]])
        vis.plot_sample(data, vent=(0, 0), log=False, values="Contributions",
                        bounds=(min(min(contributions)),
                                max(max(contributions))),
                        title=phi_new[j]["interval"],
                        cbar_label="Error Contribution",
                        ax=axs[j], cmap="hot",
                        wind=(params_list[i]["u"], params_list[i]["v"]))
        axs[j].set_xlim([-3000, 6500])
        axs[j].set_ylim([-500, 12000])
    plt.tight_layout()
    plt.show()

    # PHI AND SPATIAL RESIDUALS
    fig, axs = plt.subplots(3, 3, figsize=(
        15, 15), facecolor='w', edgecolor='k')
    axs = axs.ravel()
    for j, phi_step in enumerate(phi_new):
        post_df["mass_res"] = (post_df["MassArea"].values *
                               (post_df[phi_step["interval"]].values/100)) /\
            (data["MassArea"].values*(data[phi_step["interval"]].values/100))
        vis.plot_residuals(post_df, vent=(0, 0), values="mass_res",
                           plot_type="size",
                           title=prior_phi_steps[j]["interval"],
                           ax=axs[j], wind=(params_list[i]["u"],
                           params_list[i]["v"]))
        axs[j].set_xlim([-3000, 6500])
        axs[j].set_ylim([-500, 12000])
    plt.tight_layout()
    plt.show()

# %%
""" ## Prior TGSD setup

Here we set up the prior TGSD. Normally we would use either a Naive estimation
of the TGSD, or a uniform prior, as a starting point for the inversion.

Here we can also drop any phi classes that we do not wish to include in the
inversion.
"""

# %%

data_set = forward_df

tgsd = inv.get_tgsd(data_set, naive_phi_steps)

# prior_phi_steps = copy.deepcopy(naive_phi_steps)
# for i, phi in enumerate(prior_phi_steps):
#     #     phi["probability"] = 1/8
#     phi["probability"] = tgsd[i]

prior_phi_steps = []
for i, phi in enumerate(theo_phi_steps):
    phi_cpy = copy.deepcopy(phi)
    prior_phi_steps.append(phi_cpy)

# Drop two fines classes
# del prior_phi_steps[-1]
# del prior_phi_steps[-1]

io.print_table(pd.DataFrame(prior_phi_steps))
io.print_table(pd.DataFrame(new_steps))

# %%
""" ## Inversion

Here we run the full inversion scheme. This consists of running multiple
repeated inversions that can be compared in detail using the diagnostics in the
following cell.

See the documentation for the `gaussian_stack_multi_run` function for details
on the input parameters.
"""

# %%
# Goodness of fit measure.
gof = "chi-sqr"

# Number of complete iterations.
iterations = 1

out = inv.gaussian_stack_multi_run(
    data_set,
    len(data_set),
    int(add_params["INV_STEPS"]),
    config["VENT_ELEVATION"],
    add_params["THEO_MAX_COL"],
    2500,
    prior_phi_steps,
    config["ERUPTION_MASS"],
    param_config,
    runs=iterations,
    column_cap=add_params["THEO_MAX_COL"],
    pre_samples=1,
    sol_iter=20,
    max_iter=40,
    tol=7,
    termination="std",
    adjust_TGSD=True,
    adjust_mass=False,
    gof=gof,
    adjustment_factor=None,
    abort_method="too_slow"
)
inverted_masses_list, misfit_list, params_list, priors_list, heights, \
        tgsd_list, mass_list, status_list, message_list = out

# %%
"""
## Inversion Diagnostics
"""

# %%

if gof == "RMSE":
    denom = max(data_set["MassArea"]) - min(data_set["MassArea"])
    misfit_list = [mf/denom for mf in misfit_list]

best = np.argsort(misfit_list)

q_mass = inv.beta_plume(config["ALPHA"], config["BETA"],
                        config["PLUME_HEIGHT"],
                        config["ERUPTION_MASS"],
                        heights,
                        config["VENT_ELEVATION"],
                        add_params["THEO_MAX_COL"])


fig, ax1 = plt.subplots(1, 1, figsize=(6, 20), facecolor='w', edgecolor='k')

ax1.plot(inverted_masses_list[best[0]],
         heights,
         '-', label="Run %d (Best); Misfit = %g" %
         (best[0], misfit_list[best[0]]))


for i in best[0:]:
    if status_list[i]:
        linetype = '-'
        label = "Run %d; Misfit = %g" % (i, misfit_list[i])
    else:
        linetype = '--'
        label = "Run %d; Misfit = %g (ABORTED)" % (i, misfit_list[i])
    ax1.plot(inverted_masses_list[i],
             heights,
             linetype, label=label)
ax1.legend(loc='upper center', bbox_to_anchor=(0.5, -0.1))
ax1.set_title("All fits")
ax1.set_ylabel("Height")
ax1.set_xlabel("Mass/Area")
plt.tight_layout()
plt.show()

fig, ax1 = plt.subplots(1, 1, figsize=(6, 6), facecolor='w', edgecolor='k')
ax1.plot(inverted_masses_list[best[0]],
         heights,
         '-', label="Run %d (Best); Misfit = %g" %
         (best[0], misfit_list[best[0]]))
ax1.plot(q_mass, heights, label="Prior Mean Column")
ax1.legend(loc='upper center', bbox_to_anchor=(0.5, -0.1))
ax1.set_title("Best fit")
ax1.set_ylabel("Height")
ax1.set_xlabel("Mass/Area")
plt.tight_layout()
plt.show()

params_df = pd.DataFrame(params_list)
params_df['95_percentile'] = params_df.apply(
    lambda row: beta.ppf(.95, row.a, row.b, loc=config["VENT_ELEVATION"],
                         scale=row.h1), axis=1)
params_df["M"] = mass_list
params_df["Misfit"] = misfit_list
params_df["Success"] = status_list
params_df["Status"] = message_list
params_df = params_df.sort_values("Misfit")
params_df = params_df[["a", "b", "h1", "95_percentile", "u", "v",
                       "D", "ftt", "M", "Misfit", "Success", "Status"]]

io.print_table(params_df)

priors_vals = {
    "a": config["ALPHA"],
    "b": config["BETA"],
    "h1": config["PLUME_HEIGHT"],
    "u": u,
    "v": v,
    "D": config["DIFFUSION_COEFFICIENT"],
    "ftt": config["FALL_TIME_THRESHOLD"],
}

# %%
for i in best[0:2]:
    data = data_set.copy()

    data = data[data["MassArea"] > 0]
    io.print_table(pd.DataFrame([priors_vals, params_list[i]]))

    fig, ax1 = plt.subplots(1, 1, figsize=(6, 6), facecolor='w', edgecolor='k')
    ax1.plot(q_mass, heights, label="Prior Mean Column")
    ax1.plot(inverted_masses_list[best[0]],
             heights,
             '-', label="Run %d (Best); Misfit = %g" %
             (best[0], misfit_list[best[0]]))
    label = "Run %d; Misfit = %g" % (i, misfit_list[i])
    ax1.plot(inverted_masses_list[i],
             heights,
             '-', label=label)
    ax1.legend(loc='upper center', bbox_to_anchor=(0.5, -0.1))
    ax1.set_title("Run %d" % i)
    ax1.set_ylabel("Height")
    ax1.set_xlabel("Mass/Area")
    plt.tight_layout()
    plt.show()

    phi_new = copy.deepcopy(prior_phi_steps)
    for j, phi in enumerate(phi_new):
        phi["probability"] = tgsd_list[i][j]

    q_dist = beta(params_list[i]["a"], params_list[i]["b"])

    grid = data[["Easting", "Northing"]]

    post_df = inv.gaussian_stack_forward(
        grid, int(config["COL_STEPS"]), config["VENT_ELEVATION"],
        params_list[i]["h1"], 2500, phi_new, (
            params_list[i]["a"], params_list[i]["b"]),
        mass_list[i],
        (params_list[i]["u"], params_list[i]["v"]
         ), params_list[i]["D"], config["EDDY_CONST"],
        params_list[i]["ftt"]
    )

    post_df["radius"] = np.sqrt(post_df["Easting"]**2 + post_df["Northing"]**2)
    post_df = post_df.sort_values(by=['radius'])
    post_df["Residual"] = post_df["MassArea"].values/data["MassArea"].values

    # SPATIAL PLOTS

    fig, axs = plt.subplots(3, 1, figsize=(
        6, 18), facecolor='w', edgecolor='k')
    axs = axs.ravel()
    bounds = (50, 800)
    vis.plot_sample(data, vent=(0, 0), log=False, bounds=bounds,
                    title="Observation Dataset", cbar_label="Mass/Area",
                    ax=axs[0],
                    wind=(params_list[i]["u"], params_list[i]["v"]))
    axs[0].set_xlim([-3000, 6500])
    axs[0].set_ylim([-500, 12000])
    vis.plot_sample(post_df, vent=(0, 0), log=False, bounds=bounds,
                    title="Posterior Simulation", cbar_label="Mass/Area",
                    ax=axs[1],
                    wind=(params_list[i]["u"], params_list[i]["v"]))
    axs[1].set_xlim([-3000, 6500])
    axs[1].set_ylim([-500, 12000])
    vis.plot_residuals(post_df, vent=(0, 0), values="Residual",
                       plot_type="size",
                       title="Residual wrt. Obs.", ax=axs[2],
                       wind=(params_list[i]["u"], params_list[i]["v"]))
    axs[2].set_xlim([-3000, 6500])
    axs[2].set_ylim([-500, 12000])

    plt.tight_layout()
    plt.show()

    # EQUILINE PLOT

    min_mass = min((min(data["MassArea"].values),
                   min(post_df["MassArea"].values)))
    max_mass = max((max(data["MassArea"].values),
                   max(post_df["MassArea"].values)))

    fig, ax = plt.subplots(facecolor='w', edgecolor='k')
    ax.scatter(np.sqrt(data["MassArea"].values),
               np.sqrt(post_df["MassArea"].values))
    ax.plot([0, 100], [0, 100], "k:")
    ax.set_xlabel("SQRT(Observed)")
    ax.set_ylabel("SQRT(Calculated)")
    ax.set_aspect('equal', 'box')
    ax.set_xlim([np.sqrt(min_mass)-1, np.sqrt(max_mass)+1])
    ax.set_ylim([np.sqrt(min_mass)-1, np.sqrt(max_mass)+1])
    fig.tight_layout()
    plt.show()

    # DISTANCE PLOTS
    fig, axs = plt.subplots(2, 1, figsize=(
        8, 9), facecolor='w', edgecolor='k')
    axs = axs.ravel()

    axs[0].plot(data["radius"].values, data["MassArea"].values,
                'C2o-', label="Observation Data")
    axs[0].plot(post_df["radius"].values, post_df["MassArea"].values,
                'C1o', label="Posterior Simulation")
    axs[0].legend()
    axs[0].set_xlabel("Distance from vent (m)")
    axs[0].set_ylabel("Mass/Area")
    axs[0].set_xlim(1000, 13000)

    axs[1].plot(post_df["radius"].values,
                post_df["Residual"].values*100, 'C1o', label="Post/Obs")
    axs[1].axhline(100, linestyle="--", lw=1, c="gray")
    axs[1].legend()
    axs[1].set_xlabel("Distance from vent (m)")
    axs[1].set_ylabel("Sim as % of Real")
    axs[1].set_xlim(1000, 13000)
    plt.show()

    # TGSD PLOTS

    old_tgsd = [phi["probability"] for phi in prior_phi_steps]
    x = [phi["centroid"] for phi in phi_new]
    labels = [phi["interval"] for phi in phi_new]

    obs_tgsd = inv.get_tgsd(data, phi_new)
    post_tgsd = inv.get_tgsd(post_df, phi_new)

    fig, ax = plt.subplots(facecolor='w', edgecolor='k')
    ax.bar([xx-0.25 for xx in x], old_tgsd, width=0.5,
           align="center", label="Input TGSD")
    ax.bar([xx+0.25 for xx in x], tgsd_list[i],
           width=0.5, align="center", label="Post. TGSD")
    ax.set_xticks(x)
    ax.set_xticklabels(labels, rotation=90)
    ax.set_xlabel("Phi Interval")
    plt.title("TGSD before and after inversion")
    plt.legend()

    plt.show()

    fig, ax = plt.subplots(facecolor='w', edgecolor='k')
    ax.bar([xx-0.25 for xx in x], obs_tgsd, width=0.5,
           align="center", label="Obs. TGSD (Naive)")
    ax.bar([xx+0.25 for xx in x], post_tgsd, width=0.5,
           align="center", label="Post. TGSD (Naive)")
    ax.set_xticks(x)
    ax.set_xticklabels(labels, rotation=90)
    ax.set_xlabel("Phi Interval")
    plt.title("Naive estimation of TGSD")
    plt.legend()

    plt.show()

    # ERROR CONTRIBUTION PLOTS

    new_steps = copy.deepcopy(prior_phi_steps)
    for j, phi in enumerate(new_steps):
        phi["probability"] = tgsd_list[i][j]

    misfit, contributions, setup = inv.get_error_contributions(
        data, len(data), int(add_params["INV_STEPS"]),
        config["VENT_ELEVATION"], add_params["THEO_MAX_COL"], 2500, new_steps,
        params_list[i], mass_list[i], column_cap=add_params["THEO_MAX_COL"],
        gof=gof)

    point_contributions = np.sum(contributions, 0)
    phi_contributions = np.sum(contributions, 1)

    print("Full misfit", misfit)

    print("Point Contributions", point_contributions)
    print("Phi Contributions", phi_contributions)

    print("Sum of Point Conts:", sum(point_contributions))
    print("Sum of Phi Conts:", sum(phi_contributions))

    # Phi Error Contributions
    fig, ax = plt.subplots(facecolor='w', edgecolor='k')
    ax.bar(x, phi_contributions, width=0.5, align="center")
    ax.set_xticks(x)
    ax.set_xticklabels(labels)
    plt.xlabel("Phi Interval")
    plt.ylabel("Error Contribution")
    plt.title("Run %d" % i)
    plt.show()

    # Distance Error Contributions
    fig, ax = plt.subplots(facecolor='w', edgecolor='k')
    ax.plot(data["radius"], point_contributions, "C0o-")
    plt.xlabel("Distance from Vent")
    plt.ylabel("Error Contribution")
    plt.title("Run %d" % i)
    ax.set_xlim(1000, 13000)
    plt.show()

    # Spatial Error Contributions
    data["Contributions"] = point_contributions
    fig, ax = plt.subplots(1, 1, figsize=(5, 5), facecolor='w', edgecolor='k')

    vis.plot_sample(data, vent=(0, 0), log=False, values="Contributions",
                    title="Error Contributions", cbar_label="Mass/Area", ax=ax,
                    cmap="hot")
    ax.set_xlim([-3000, 6500])
    ax.set_ylim([-500, 12000])
    plt.tight_layout()
    plt.show()
#      bounds=(min(min(contributions)),max(max(contributions))),
    # Phi and Spatial Error Contributions
    fig, axs = plt.subplots(3, 3, figsize=(
        15, 15), facecolor='w', edgecolor='k')
    axs = axs.ravel()
    for j, phi_cont in enumerate(phi_contributions):
        data["Contributions"] = contributions[j]
#         display(data[["Contributions", "MassArea"]])
        vis.plot_sample(data, vent=(0, 0), log=False, values="Contributions",
                        bounds=(min(min(contributions)),
                                max(max(contributions))),
                        title=phi_new[j]["interval"],
                        cbar_label="Error Contribution",
                        ax=axs[j], cmap="hot",
                        wind=(params_list[i]["u"], params_list[i]["v"]))
        axs[j].set_xlim([-3000, 6500])
        axs[j].set_ylim([-500, 12000])
    plt.tight_layout()
    plt.show()

    # PHI AND SPATIAL RESIDUALS
    fig, axs = plt.subplots(3, 3, figsize=(
        15, 15), facecolor='w', edgecolor='k')
    axs = axs.ravel()
    for j, phi_step in enumerate(phi_new):
        post_df["mass_res"] = (post_df["MassArea"].values *
                               (post_df[phi_step["interval"]].values/100)) /\
            (data["MassArea"].values*(data[phi_step["interval"]].values/100))

        disp_df = post_df[["Northing", "Easting",
                           "MassArea", phi_step["interval"], "mass_res"]]
        disp_df["Obs. MassArea"] = data["MassArea"].values
        disp_df[("Obs. " + phi_step["interval"])
                ] = data[phi_step["interval"]].values
        disp_df.rename(columns={'MassArea': 'Post. MassArea',
                                phi_step["interval"]:
                                ("Post. " + phi_step["interval"]),
                                "mass_res": "Residual"},
                       inplace=True)
        vis.plot_residuals(post_df, vent=(0, 0), values="mass_res",
                           plot_type="size",
                           title=prior_phi_steps[j]["interval"],
                           ax=axs[j], wind=(params_list[i]["u"],
                           params_list[i]["v"]))
        axs[j].set_xlim([-3000, 6500])
        axs[j].set_ylim([-500, 12000])
    plt.tight_layout()
    plt.show()

# %% Prior explanations man

fig, axs = plt.subplots(3, 2, figsize=(10, 10), facecolor='w', edgecolor='k')
axs = axs.ravel()

params_frames = []

priors_df = pd.DataFrame(priors_list)
params_df = pd.DataFrame(params_list)
misfit_df = pd.DataFrame(misfit_list)

failed_list = [not s for s in status_list]

for i, col in enumerate(priors_df.columns[:-1]):
    cb = axs[i].scatter(priors_df[col], params_df[col], c=misfit_df,
                        norm=colors.PowerNorm(gamma=1/6), cmap="viridis_r")
    axs[i].scatter(priors_df[col][failed_list],
                   params_df[col][failed_list],
                   marker="x")
    axs[i].set_title(col)
    axs[i].set_xlabel("Prior")
    axs[i].set_ylabel("Post")
plt.colorbar(cb)
plt.tight_layout()
plt.show()



















