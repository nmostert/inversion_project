# %%
"""
# Cerronegro Statistical Consistency Test
"""

# %%
import copy
from tabulate import tabulate
from pandas import ExcelWriter
from functools import reduce
from time import process_time
from scipy.optimize import minimize
from scipy.sparse.linalg import lsqr
from scipy.stats import beta, expon, truncnorm, norm, uniform
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import sys
sys.path.append("..")
import project.vis_utils as vis
import project.io_utils as io
import project.inversion as inv
import matplotlib.colors as colors
import json
pd.options.display.float_format = '{:,g}'.format
plt.rcParams['text.usetex'] = True
plt.style.use(['ggplot'])


# %%
""" ### Observation Data

Reading in Cerro Negro observation dataset and extracting grid
"""

# %%
filename = "../data/cerronegro/cerronegro_real_data.csv"

raw_df, grid_raw = io.import_cerronegro(filename, layers=["A", "M"])

grid = io.read_grid("../data/cerronegro/cerronegro_grid_layers_AM.csv")

io.print_table(raw_df[["Easting", "Northing", "MassArea"]])

io.print_table(grid)
io.print_table(grid_raw)
print(len(grid))
print(len(grid_raw))
# %%
""" ##Reading in Tephra2 dataset

To demonstrate consistency with Tephra2, this dataset must be generated by
Tephra2 using the exact same parameters as is used in the forward modelling.
"""

# %%
t2_df, _, _, _ \
        = io.read_tephra2("../data/cerronegro/cerronegro_output_layers_AM.txt")

io.print_table(t2_df.head())

# %%
""" ## Set up inversion configuration

- Read in Tephra2 config file
- Set global parameters
- Set other inversion parameters

# Statistical consistency requirements

In order to demonstrate perfect statistical consistency we need our forward
model to invert perfectly, i.e. return the exact input parameters that
simulated it. Such a perfect inversion requires that the release points in the
column be in exactly the same place in the forward model as in the inversion.

The forward model evenly spaces the release points between the vent height and
the plume height, putting a point at each. In order to demonstrate statistical
consistency, those same points need to be used for inversion. To this end, a
theoretical maximum column height and number of inversion column steps is
calculated that places release points for inversion at those same points in the
column that would be used in the forward model, while adding evenly spaced
points above the actual plume height.
If statistical consistency is not required these values can be set for
efficient inversion.
"""

# %%
config = io.read_config_file("../data/cerronegro/cerronegro_config.txt")

globs = {
    "LITHIC_DIAMETER_THRESHOLD": 7.,
    "PUMICE_DIAMETER_THRESHOLD": -1.,
    "AIR_VISCOSITY": 0.000018325,
    "AIR_DENSITY":  1.293,
    "GRAVITY": 9.81,
}

for key in config.keys():
    config[key] = float(config[key])

# config["MIN_GRAINSIZE"] = int(config["MIN_GRAINSIZE"])
# config["MAX_GRAINSIZE"] = float(config["MAX_GRAINSIZE"])
config["COL_STEPS"] = int(config["COL_STEPS"])
config["PART_STEPS"] = int(config["PART_STEPS"])
# Update parameters
# COL STEPS need to be small enough so the
# layer height can be kept for an inversion with a high H
config["COL_STEPS"] = 75
theoretical_max = 10000  # The H value will be as close as possible to this
layer_thickness = (
    (config["PLUME_HEIGHT"]-config["VENT_ELEVATION"])/config["COL_STEPS"])

inversion_steps = np.round((config["COL_STEPS"]*(theoretical_max -
                            config["VENT_ELEVATION"])) /
                           (config["PLUME_HEIGHT"]-config["VENT_ELEVATION"]))
closest_H = ((inversion_steps*(config["PLUME_HEIGHT"] -
             config["VENT_ELEVATION"])) /
             config["COL_STEPS"]) + config["VENT_ELEVATION"]
print("This number needs to be low enough to invert efficiently:")
print(inversion_steps)
print("If not, decrease COL_STEPS or theoretical max")
print("Closest Possible Theoretical Max Column Height:")
print(closest_H)

add_params = {
    # Constant wind speed (m/s)
    "WIND_SPEED": 10,
    # Constant wind angle (radians anti-clockwise from Easting)
    "WIND_ANGLE": np.radians(190),
    "INV_STEPS": int(inversion_steps),
    "THEO_MAX_COL": closest_H
}

# To ensure monotonicity:
# config["DIFFUSION_COEFFICIENT"] = 1.7*config["FALL_TIME_THRESHOLD"]

print("INPUT PARAMETERS:")
io.print_table(config, tablefmt="latex")
io.print_table(globs, tablefmt="latex")
io.print_table(add_params)

# %%
""" ## Phi class calculations

# Theoretical phi parameters

These are the phi-bins as calculated using the log-normal representation
of the TGSD from the grain-size parameters.

The function `get_phi_steps` generates phi classes using Tephra2 input
variables in the exact same way as Tephra2.
"""

# %%
theo_phi_steps = inv.get_phi_steps(config["MIN_GRAINSIZE"],
                                   config["MAX_GRAINSIZE"],
                                   config["PART_STEPS"],
                                   config["MEDIAN_GRAINSIZE"],
                                   config["STD_GRAINSIZE"],
                                   globs["LITHIC_DIAMETER_THRESHOLD"],
                                   globs["PUMICE_DIAMETER_THRESHOLD"],
                                   config["LITHIC_DENSITY"],
                                   config["PUMICE_DENSITY"])
step_width = (config["MAX_GRAINSIZE"] -
              config["MIN_GRAINSIZE"])/config["PART_STEPS"]

io.print_table(pd.DataFrame(theo_phi_steps))


probs = [phi["probability"].copy() for phi in theo_phi_steps]
x = [phi["centroid"] for phi in theo_phi_steps]
labels = [phi["interval"] for phi in theo_phi_steps]
fig, ax = plt.subplots(facecolor='w', edgecolor='k')
ax.bar(x, probs, width=1, align="center")
ax.set_xticks(x)
ax.set_xticklabels(labels)
plt.xlabel("Phi Interval")
plt.show()

# %%
""" ## Forward modelling

Our forward model is as close to Tephra2 as possible, except that it does not
support separate wind levels.
"""

# %%

u = add_params["WIND_SPEED"]*np.cos(add_params["WIND_ANGLE"])
v = add_params["WIND_SPEED"]*np.sin(add_params["WIND_ANGLE"])

forward_df = inv.gaussian_stack_forward(
    grid, int(config["COL_STEPS"]), config["VENT_ELEVATION"],
    config["PLUME_HEIGHT"], 1, theo_phi_steps, (
        config["ALPHA"], config["BETA"]),
    config["ERUPTION_MASS"],
    (u, v), config["DIFFUSION_COEFFICIENT"], config["EDDY_CONST"],
    config["FALL_TIME_THRESHOLD"]
)

forward_df["radius"] = np.sqrt(
    forward_df["Easting"]**2 + forward_df["Northing"]**2)
forward_df["Residual"] = forward_df["MassArea"].values / \
    t2_df["MassArea"].values
io.print_table(forward_df.head())
print("Wind parameters:")
print("u = %g, v = %g" % (u, v))
# %%
""" ## Visual Analysis

Here we use our plotting library to visualise the observation and synthetic
datasets.
"""

# %%

fig, axs = plt.subplots(1, 2, figsize=(
    14, 5),
    gridspec_kw={'width_ratios': [.8, 1]})
axs = axs.ravel()

vis.plot_sample(forward_df, vent=(0, 0), log=True, bounds=(50, 1500),
                show_cbar=False,
                title=r"Forward Simulation (Const. Wind)",
                cbar_label=r"Mass/Area", ax=axs[0])
vis.plot_sample(t2_df, vent=(0, 0), log=True, bounds=(50, 1500),
                title=r"Tephra2 Simulation (Const. Wind)",
                cbar_label=r"Mass/Area (kg/m$^3$)", ax=axs[1])
axs[0].set_xlim([-13500, 500])
axs[0].set_ylim([-5500, 3000])
axs[1].set_xlim([-13500, 500])
axs[1].set_ylim([-5500, 3000])
plt.tight_layout()
plt.show()


# %%
""" ### Residual plots

These plots compare the synthetic datasets with the observation dataset in each
case.

The residual calculation is: `(synthetic/observation)*100`
"""

# %%
# fig, axs = plt.subplots(1, 2, figsize=(
#     18, 6), facecolor='w', edgecolor='k')
# axs = axs.ravel()


vis.plot_residuals(t2_df, forward_df, vent=(0, 0), values="MassArea",
                   title="Forward simulation mass/area as a percentage of Tephra2 simulated mass/area",
                   plot_type="size")

plt.tight_layout()
plt.show()

# fig, axs = plt.subplots(1, 2, figsize=(
#     18, 6), facecolor='w', edgecolor='k')
# axs = axs.ravel()


# vis.plot_residuals(forward_df, vent=(0, 0), values="Residual",
#                    title="Forward Simulation (Const. Wind)",
#                    plot_type="cmap", ax=axs[0], show_cbar=False)
# vis.plot_residuals(t2_df, vent=(0, 0), values="Residual",
#                    title="Tephra2 Simulation (Const. Wind)",
#                    plot_type="cmap", ax=axs[1], show_cbar=True)


# plt.tight_layout()
# plt.show()

# %%
""" ### Distance plots

These plots sort the points by their distance from the vent, giving a general
sense of the decay curves in all directions from the vent.
"""

# %%
fig, axs = plt.subplots(2, 1, figsize=(
    8, 10), facecolor='w', edgecolor='k')
axs = axs.ravel()

# axs[0].plot(obs_df["radius"].values, obs_df["MassArea"].values,
#            'C0o-', label="Observations")
# plt.plot(rotdf["radius"].values, rotdf["MassArea"].values, 'C1o-')
axs[0].plot(forward_df["radius"].values, forward_df["MassArea"].values,
            'C0o', label="Forward (Const. Wind)")
axs[0].plot(t2_df["radius"].values, t2_df["MassArea"].values,
            'C1*', label="Tephra2 (NOAA Wind)")
axs[0].legend()
axs[0].set_xlabel("Distance from vent (m)")
axs[0].set_ylabel("Mass/Area")

axs[1].plot(forward_df["radius"].values, forward_df["Residual"].values *
            100, 'C1o', label="Forward (Const. Wind)")
# axs[1].plot(t2_df["radius"].values, t2_df["Residual"].values *
#             100, 'C3o', label="Tephra2 (NOAA Wind)")
axs[1].axhline(100, linestyle="--", lw=1, c="gray")
axs[1].legend()
axs[1].set_xlabel("Distance from vent (m)")
axs[1].set_ylabel(r"Forward Sim as \% of T2 Sim")
plt.show()


# %%
""" ## Prior Distributions

Here we can define prior distributions to be used in the inversion. These will
passed to the sampler using the `param_config` dict below.


"""
# %%


def col_truncnorm(mean, top=add_params["THEO_MAX_COL"]):
    bottom = 5000
    std = (top - bottom)/4
    standard_a, standard_b = (bottom - mean) / std, (top - mean) / std
    return truncnorm.rvs(standard_a, standard_b, loc=mean, scale=std)


def lognorm(prior, bottom=0):
    std_norm = norm.rvs()
    std_lognorm = np.exp(std_norm)
    lognorm = bottom + (prior-bottom)*std_lognorm
    return lognorm


def normal(prior):
    std_norm = norm.rvs()
    normal = prior*std_norm
    return normal


def uninformed(bottom, top):
    unif = uniform.rvs(loc=bottom, scale=(top-bottom))
    return unif


methods = {
        "col_truncnorm": col_truncnorm,
        "lognorm": lognorm,
        "normal": normal,
        "uniform": uninformed
        }
# %%
""" ## Parameter Configuration

Here configure the inversion parameters.

- `"value"` is a list of distribution parameters used in the sample function.
    These will be splat into the sample function during sampling, so they need
    to be in the correct order.
- `"invert"` is a boolean value indicating if the parameter should be inverted
    or not. If True, the parameter will be optimized during the
    downhill-simplex phase. Otherwise the parameter will be kept fixed.
- `"sample_function"` is the prior distribution to sample from during the
    initial sampling phase. These are chosen from the above list.
"""

# %%
param_config = {
    "a": {
        "value": [1.01, 5],
        "invert": True,
        "sample_function": "uniform"
    },
    "b": {
        "value": [1.01, 5],
        "invert": True,
        "sample_function": "uniform"
    },
    "h1": {
        "value": [1000, add_params["THEO_MAX_COL"]],
        "invert": True,
        "sample_function": "uniform"
    },
    "u": {
        "value": [0, 10],
        "invert": True,
        "sample_function": "uniform"
    },
    "v": {
        "value": [0, 10],
        "invert": True,
        "sample_function": "uniform"
    },
    "D": {
        "value": [0.5*config["FALL_TIME_THRESHOLD"],
                  1.4*config["FALL_TIME_THRESHOLD"]],
        "invert": True,
        "sample_function": "uniform"
    },
    "ftt": {
        "value": [config["FALL_TIME_THRESHOLD"], 10000],
        "invert": False,
        "sample_function": "uniform"
    },
}


print(json.dumps(param_config))

param_config_df = pd.DataFrame(param_config)
io.print_table(param_config_df.T)

fig, axs = plt.subplots(3, 3, figsize=(15, 15), facecolor='w', edgecolor='k')
axs = axs.ravel()

for i, (key, val) in enumerate(param_config.items()):
    x = [methods[val["sample_function"]](*val["value"]) for i in range(1000)]
    axs[i].hist(x)
    axs[i].set_title(key)
plt.show()

# %%
""" ## Inversion Test

This inversion test uses exact priors so that no actual inversion needs to be
done in the inversion of the forward model. With this biased inversion we can
test internal consistency. The input parameters need to be recovered exactly
for this test to pass.

In this test, we will be able to compare some or all of the following datasets,
the most important of which is the Forward model inversion using fixed priors.

# No inversion.
A forward modeled dataset is added, and inversion is NOT performed on it. This
gives us a baseline, and allows us to confirm the following:
    - The residual analysis plots are accurate. A dataset compared directly
    with itself should show zero residual.

# Forward model inversion using fixed priors.
This inversion should not change the parameters, as they are already optimised.
If this inversion changes the parameters then we don't have a stable model.

# tephra2 inversion with constant wind.
Since our assumption is that Tephra2 is functionally identical to our forward
model in the case of a fixed wind profile, the results of this inversion should
be identical to the Forward model inversion. If this is not the case, we no
longer have consistency with the Tephra2 code, which is a problem.
"""

# %%
prior_phi_steps = []
for i, phi in enumerate(theo_phi_steps):
    phi_cpy = copy.deepcopy(phi)
    prior_phi_steps.append(phi_cpy)

z = np.linspace(config["VENT_ELEVATION"] + layer_thickness,
                add_params["THEO_MAX_COL"], add_params["INV_STEPS"])
q_dist = beta(config["ALPHA"], config["BETA"])

q_mass = inv.beta_plume(config["ALPHA"], config["BETA"],
                        config["PLUME_HEIGHT"],
                        config["ERUPTION_MASS"],
                        z,
                        config["VENT_ELEVATION"],
                        add_params["THEO_MAX_COL"])

forward_param_vals = {
    "a": config["ALPHA"],
    "b": config["BETA"],
    "h1": config["PLUME_HEIGHT"],
    "u": u,
    "v": v,
    "D": config["DIFFUSION_COEFFICIENT"],
    "ftt": config["FALL_TIME_THRESHOLD"]
}

priors_vals = {
    "a": param_config["a"]["sample_function"](*param_config["a"]["value"]),
    "b": param_config["b"]["sample_function"](*param_config["b"]["value"]),
    "h1": param_config["h1"]["sample_function"](*param_config["h1"]["value"]),
    "u": param_config["u"]["sample_function"](*param_config["u"]["value"]),
    "v": param_config["v"]["sample_function"](*param_config["v"]["value"]),
    "D": param_config["D"]["sample_function"](*param_config["D"]["value"]),
    "ftt": config["FALL_TIME_THRESHOLD"]
}

invert_params = {
    "a": param_config["a"]["invert"],
    "b": param_config["b"]["invert"],
    "h1": param_config["h1"]["invert"],
    "u": param_config["u"]["invert"],
    "v": param_config["v"]["invert"],
    "D": param_config["D"]["invert"],
    "ftt": False
}


t_tot = process_time()
single_run_time = 0

names = ["No Inversion", "Forward Sim"]
data_sets = [forward_df, forward_df]

inverted_masses_list = []
inverted_masses_list += [q_mass]
params_list = []
sim_params = forward_param_vals
params_list += [sim_params]
mass_list = []
tgsd_list = []
misfit_list = []
mass_list += [config["ERUPTION_MASS"]]
tgsd_list += [[phi["probability"].copy() for phi in prior_phi_steps]]
misfit_list += ["--"]

for name, df in zip(names[1:], data_sets[1:]):
    t = process_time()
    run_phis = copy.deepcopy(prior_phi_steps)
    print("========%s========" % name)
    out = inv.gaussian_stack_inversion(
        df, len(df), add_params["INV_STEPS"], config["VENT_ELEVATION"],
        add_params["THEO_MAX_COL"], 1, run_phis, config["ERUPTION_MASS"],
        invert_params=invert_params,
        priors=priors_vals, sol_iter=20,
        max_iter=40, tol=1e-6, termination="norm_diff",
        adjust_TGSD=False, adjust_mass=False,
        adjustment_factor=None,
        abort_method="too_slow",
        column_cap=add_params["THEO_MAX_COL"],
    )
    inversion_table, params, misfit, status, message, param_trace, \
        misfit_trace, tgsd_trace, mass_trace = out
    inv_mass = inversion_table["Suspended Mass"].values
    inverted_masses_list += [inv_mass]
    params_list += [params]
    tgsd_list += [tgsd_trace[-2]]
    mass_list += [mass_trace[-1]]
    misfit_list += [misfit]
    io.print_table(inversion_table)
    param_trace = np.array(param_trace)
    fig, axs = plt.subplots(3, 3, figsize=(
        11, 9), facecolor='w', edgecolor='k')
    axs = axs.ravel()
    axs[0].plot(param_trace[:, 0], linewidth=.8)
    axs[0].set_title("a")

    axs[1].plot(param_trace[:, 1], linewidth=.8)
    axs[1].set_title("b")

    axs[2].plot(param_trace[:, 2], linewidth=.8)
    axs[2].set_title("h1")

    axs[3].plot(param_trace[:, 3], linewidth=.8)
    axs[3].set_title("u")

    axs[4].plot(param_trace[:, 4], linewidth=.8)
    axs[4].set_title("v")

    axs[5].plot(param_trace[:, 5], linewidth=.8)
    axs[5].set_title("Diffusion Coefficient")

    axs[8].plot(misfit_trace, linewidth=.8)
    axs[8].set_title("GoF")

#     print(sse_trace)

    plt.tight_layout()
    # plt.savefig("colima/real_trace.png", dpi=200, format='png')
    plt.show()
    # fig, ax = plt.subplots(facecolor='w', edgecolor='k')
    # ax.bar(x, tgsd_trace[0], width=1, align="center")
    # ax.set_xticks(x)
    # ax.set_xticklabels(labels)
    # plt.xlabel("Phi Interval")
    # plt.title("Before")
    # plt.show()

    # fig, ax = plt.subplots(facecolor='w', edgecolor='k')
    # ax.bar(x, tgsd_trace[-1], width=1, align="center")
    # ax.set_xticks(x)
    # ax.set_xticklabels(labels)
    # plt.xlabel("Phi Interval")
    # plt.title("After")
    # plt.show()

    run_time = process_time() - t
    print("%s Run Time: %.5f minutes\n\n" % (name, run_time/60))


total_run_time = process_time() - t_tot

print("Total Run Time: %.5f minutes" % (total_run_time/60))

# %%
""" ## TGSD Adjustment Results

If TGSD adjustment is toggled off in the tests above, this should show no
change. Otherwise this will show the TGSD adjustment for each dataset.

Forward Sim and No Inversion should have no TGSD adjustment, even when toggled
on.
"""

# %%

fig, ax = plt.subplots(facecolor='w', edgecolor='k')
ax.bar([xx for xx in x],
       [phi["probability"] for phi in prior_phi_steps],
       width=.25, align="edge", label="Initial TGSD")
ax.bar([xx-0.25 for xx in x],
       tgsd_list[1], width=.25, align="edge", label="Inverted TGSD")
ax.set_xticks(x)
ax.set_xticklabels(labels, rotation=90)
plt.xlabel("Phi Interval")
plt.legend()
plt.show()
# %%
""" ## Inversion Results

Here we show the results of the parameter inversions.
"""

# %%
fig, ax1 = plt.subplots(1, 1, figsize=(
    8, 6), facecolor='w', edgecolor='k')

ltype = ["-", "--", ":", ".-", "."]

for name, mass, lt in zip(names, inverted_masses_list, ltype):
    ax1.plot(mass,
             inversion_table["Height"], lt, label=name)
ax1.legend()
# ax1.set_title("Mass in Column as inverted from various datasets")
ax1.set_ylabel("Height")
ax1.set_xlabel("Mass/Area")
ax1.set_title("Inverted Suspended Mass in Plume")
plt.tight_layout()
plt.show()
params_df = pd.DataFrame(params_list)
params_df["Dataset"] = names
params_df = params_df[["Dataset", "a", "b",
                       "h1", "u", "v", "D", "ftt"]]
params_df["M"] = mass_list
params_df["Misfit"] = misfit_list
io.print_table(params_df.T, tablefmt="latex")

# %%
""" ## Single Inversion Diagnostics

Here we can look at the diagnostics of a single inversion at a time, as opposed
to a sampled prior inversion scheme as it would usually be applied.


"""

# %%
for i, name in enumerate(names):
    print("========%s========" % name)

    data = data_sets[i]

    io.print_table(params_list[i])

    print("GoF: ", misfit_list[i])
    q_dist = beta(params["a"], params["b"])

    phi_new = copy.deepcopy(prior_phi_steps)
    for j, new_phi in enumerate(phi_new):
        new_phi["probability"] = tgsd_list[i][j]

    q_dist = beta(params["a"], params["b"])

    grid = data[["Easting", "Northing"]]

    post_df = inv.gaussian_stack_forward(
        grid, int(config["COL_STEPS"]), config["VENT_ELEVATION"],
        params_list[i]["h1"], 1, phi_new, (
            params_list[i]["a"], params_list[i]["b"]),
        mass_list[i],
        (params_list[i]["u"], params_list[i]["v"]
         ), params_list[i]["D"], config["EDDY_CONST"],
        config["FALL_TIME_THRESHOLD"]
    )
    if name == "No Inversion":
        data = post_df
    post_df["radius"] = np.sqrt(post_df["Easting"]**2 + post_df["Northing"]**2)
    post_df["Residual"] = post_df["MassArea"].values/data["MassArea"].values


#     display(post_df)
    # SPATIAL PLOTS
    fig, axs = plt.subplots(1, 2, figsize=(
        16, 5), facecolor='w', edgecolor='k',
        gridspec_kw={'width_ratios': [.8, 1]})
    axs = axs.ravel()
    bounds = (50, 800)
    vis.plot_sample(data, vent=(0, 0), log=False, bounds=bounds,
                    title="Forward Simulation", cbar_label="Mass/Area", ax=axs[0],
                    wind=(params_list[i]["u"], params_list[i]["v"]),
                    show_cbar=False)
    axs[0].set_xlim([-13500, 500])
    axs[0].set_ylim([-5500, 3000])
    vis.plot_sample(post_df, vent=(0, 0), log=False, bounds=bounds,
                    title="Dataset resimulated using Inverted Parameters", cbar_label="Mass/Area",
                    ax=axs[1],
                    wind=(params_list[i]["u"], params_list[i]["v"]))
    axs[1].set_xlim([-13500, 500])
    axs[1].set_ylim([-5500, 3000])

    plt.tight_layout()
    plt.show()

    vis.plot_residuals(post_df, vent=(0, 0), values="Residual",
                       plot_type="size",
                       title="Resimulated dataset as a percentage of input dataset",
                       wind=(params_list[i]["u"], params_list[i]["v"]))
    plt.xlim([-13500, 500])
    plt.ylim([-5500, 3000])
    plt.tight_layout()
    plt.show()

    # EQUILINE PLOT

    min_mass = min((min(data["MassArea"].values),
                   min(post_df["MassArea"].values)))
    max_mass = max((max(data["MassArea"].values),
                   max(post_df["MassArea"].values)))

    fig, ax = plt.subplots(facecolor='w', edgecolor='k')
    ax.scatter(np.sqrt(data["MassArea"].values),
               np.sqrt(post_df["MassArea"].values))
    ax.plot([0, 100], [0, 100], "k:")
    ax.set_xlabel("SQRT(Observed)")
    ax.set_ylabel("SQRT(Calculated)")
    ax.set_aspect('equal', 'box')
    ax.set_xlim([np.sqrt(min_mass)-1, np.sqrt(max_mass)+1])
    ax.set_ylim([np.sqrt(min_mass)-1, np.sqrt(max_mass)+1])
    fig.tight_layout()
    plt.show()

    # DISTANCE PLOTS
    fig, axs = plt.subplots(2, 1, figsize=(
        8, 9), facecolor='w', edgecolor='k')
    axs = axs.ravel()

    axs[0].plot(data["radius"].values, data["MassArea"].values,
                'C2o-', label="Observation Data")
    axs[0].plot(post_df["radius"].values, post_df["MassArea"].values,
                'C1o', label="Posterior Simulation")
    axs[0].legend()
    axs[0].set_xlabel("Distance from vent (m)")
    axs[0].set_ylabel("Mass/Area")
    # axs[0].set_xlim(1000, 13000)

    axs[1].plot(post_df["radius"].values,
                post_df["Residual"].values*100, 'C1o', label="Post/Obs")
    axs[1].axhline(100, linestyle="--", lw=1, c="gray")
    axs[1].legend()
    axs[1].set_xlabel("Distance from vent (m)")
    axs[1].set_ylabel("Sim as % of Real")
    # axs[1].set_xlim(1000, 13000)
    plt.show()

    # TGSD PLOTS

    old_tgsd = [phi["probability"].copy() for phi in prior_phi_steps]
    x = [phi["centroid"] for phi in prior_phi_steps]
    labels = [phi["interval"] for phi in prior_phi_steps]

    obs_tgsd = inv.get_tgsd(data, prior_phi_steps)
    post_tgsd = inv.get_tgsd(post_df, prior_phi_steps)

    fig, ax = plt.subplots(facecolor='w', edgecolor='k')
    ax.bar([xx for xx in x], old_tgsd, width=0.25,
           align="center", label="Prior TGSD")
    ax.bar([xx-0.25 for xx in x], tgsd_list[i],
           width=0.25, align="center", label="Post. TGSD")
    ax.set_xticks(x)
    ax.set_xticklabels(labels, rotation=90)
    ax.set_xlabel("Phi Interval")
    plt.title("TGSD before and after inversion")
    plt.legend()

    plt.show()

    fig, ax = plt.subplots(facecolor='w', edgecolor='k')
    ax.bar([xx for xx in x], obs_tgsd, width=0.25,
           align="edge", label="Obs. TGSD (Naive)")
    ax.bar([xx-0.25 for xx in x], post_tgsd, width=0.25,
           align="edge", label="Post. TGSD (Naive)")
    ax.set_xticks(x)
    ax.set_xticklabels(labels, rotation=90)
    ax.set_xlabel("Phi Interval")
    plt.title("Naive estimation of TGSD")
    plt.legend()

    plt.show()

    # ERROR CONTRIBUTION PLOTS

    new_steps = copy.deepcopy(prior_phi_steps)
    for j, phi in enumerate(new_steps):
        phi["probability"] = tgsd_list[i][j]

    misfit, contributions, setup = inv.get_error_contributions(
        data, len(data), int(add_params["INV_STEPS"]),
        config["VENT_ELEVATION"], add_params["THEO_MAX_COL"], 1, new_steps,
        params_list[i], mass_list[i], column_cap=add_params["THEO_MAX_COL"])

    print(misfit)

    # point_contributions = np.sum(contributions, 0)
    # phi_contributions = np.sum(contributions, 1)

    # # Phi Error Contributions
    # fig, ax = plt.subplots(facecolor='w', edgecolor='k')
    # ax.bar(x, phi_contributions, width=0.5, align="center")
    # ax.set_xticks(x)
    # ax.set_xticklabels(labels)
    # plt.xlabel("Phi Interval")
    # plt.ylabel("Error Contribution")
    # plt.title("Run %d" % i)
    # plt.show()

    # # Distance Error Contributions
    # fig, ax = plt.subplots(facecolor='w', edgecolor='k')
    # ax.plot(data["radius"], point_contributions, "C0o-")
    # plt.xlabel("Distance from Vent")
    # plt.ylabel("Error Contribution")
    # plt.title("Run %d" % i)
    # ax.set_xlim(1000, 13000)
    # plt.show()

    # # Spatial Error Contributions
    # data["Contributions"] = point_contributions
    # fig, ax = plt.subplots(1, 1, figsize=(5, 5), facecolor='w', edgecolor='k')

    # vis.plot_sample(data, vent=(0, 0), log=False, values="Contributions",
    #                 title="Error Contributions", cbar_label="Mass/Area",
    #                 ax=ax, cmap="hot")
    # ax.set_xlim([-13500, 500])
    # ax.set_ylim([-5500, 3000])
    # plt.tight_layout()
    # plt.show()
# #      bounds=(min(min(contributions)),max(max(contributions))),
    # # Phi and Spatial Error Contributions
    # fig, axs = plt.subplots(3, 3, figsize=(
    #     15, 15), facecolor='w', edgecolor='k')
    # axs = axs.ravel()
    # for j, phi_cont in enumerate(phi_contributions):
    #     data["Contributions"] = contributions[j]
# #         display(data[["Contributions", "MassArea"]])
    #     vis.plot_sample(data, vent=(0, 0), log=False, values="Contributions",
    #                     bounds=(min(min(contributions)),
    #                             max(max(contributions))),
    #                     title=phi_new[j]["interval"],
    #                     cbar_label="Error Contribution",
    #                     ax=axs[j], cmap="hot",
    #                     wind=(params_list[i]["u"]*20, params_list[i]["v"]*20))
    #     axs[j].set_xlim([-13500, 500])
    #     axs[j].set_ylim([-5500, 3000])
    # plt.tight_layout()
    # plt.show()

    # # PHI AND SPATIAL RESIDUALS
    # fig, axs = plt.subplots(3, 3, figsize=(
    #     15, 15), facecolor='w', edgecolor='k')
    # axs = axs.ravel()
    # for j, phi_step in enumerate(phi_new):
    #     post_df["mass_res"] = (post_df["MassArea"].values *
    #                            (post_df[phi_step["interval"]].values/100)) /\
    #         (data["MassArea"].values*(data[phi_step["interval"]].values/100))
    #     vis.plot_residuals(post_df, vent=(0, 0), values="mass_res",
    #                        plot_type="size",
    #                        title=prior_phi_steps[j]["interval"],
    #                        ax=axs[j], wind=(params_list[i]["u"]*20,
    #                        params_list[i]["v"]*20))
    #     axs[j].set_xlim([-3000, 6500])
    #     axs[j].set_ylim([-500, 12000])
    # plt.tight_layout()
    # plt.show()

